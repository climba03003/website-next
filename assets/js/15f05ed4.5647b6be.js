"use strict";(self.webpackChunk_fastify_website=self.webpackChunk_fastify_website||[]).push([[20314],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>h});var a=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},d=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),c=p(t),h=o,k=c["".concat(l,".").concat(h)]||c[h]||u[h]||r;return t?a.createElement(k,s(s({ref:n},d),{},{components:t})):a.createElement(k,s({ref:n},d))}));function h(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,s=new Array(r);s[0]=c;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var p=2;p<r;p++)s[p]=t[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},17724:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>p});var a=t(87462),o=(t(67294),t(3905));const r={},s=void 0,i={unversionedId:"Reference/Hooks",id:"version-v4.8.x/Reference/Hooks",title:"Hooks",description:"Hooks",source:"@site/versioned_docs/version-v4.8.x/Reference/Hooks.md",sourceDirName:"Reference",slug:"/Reference/Hooks",permalink:"/website-next/docs/v4.8.x/Reference/Hooks",draft:!1,editUrl:"https://github.com/fastify/fastify/edit/main/docs/Reference/Hooks.md",tags:[],version:"v4.8.x",frontMatter:{},sidebar:"docsSidebar",previous:{title:"HTTP2",permalink:"/website-next/docs/v4.8.x/Reference/HTTP2"},next:{title:"LTS",permalink:"/website-next/docs/v4.8.x/Reference/LTS"}},l={},p=[{value:"Hooks",id:"hooks",level:2},{value:"Request/Reply Hooks",id:"requestreply-hooks",level:2},{value:"onRequest",id:"onrequest",level:3},{value:"preParsing",id:"preparsing",level:3},{value:"preValidation",id:"prevalidation",level:3},{value:"preHandler",id:"prehandler",level:3},{value:"preSerialization",id:"preserialization",level:3},{value:"onError",id:"onerror",level:3},{value:"onSend",id:"onsend",level:3},{value:"onResponse",id:"onresponse",level:3},{value:"onTimeout",id:"ontimeout",level:3},{value:"Manage Errors from a hook",id:"manage-errors-from-a-hook",level:3},{value:"Respond to a request from a hook",id:"respond-to-a-request-from-a-hook",level:3},{value:"Application Hooks",id:"application-hooks",level:2},{value:"onReady",id:"onready",level:3},{value:"onClose",id:"onclose",level:3},{value:"onRoute",id:"onroute",level:3},{value:"onRegister",id:"onregister",level:3},{value:"Scope",id:"scope",level:2},{value:"Route level hooks",id:"route-level-hooks",level:2},{value:"Using Hooks to Inject Custom Properties",id:"using-hooks-to-inject-custom-properties",level:2},{value:"Diagnostics Channel Hooks",id:"diagnostics-channel-hooks",level:2}],d={toc:p};function u(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"hooks"},"Hooks"),(0,o.kt)("p",null,"Hooks are registered with the ",(0,o.kt)("inlineCode",{parentName:"p"},"fastify.addHook")," method and allow you to listen\nto specific events in the application or request/response lifecycle. You have to\nregister a hook before the event is triggered, otherwise, the event is lost."),(0,o.kt)("p",null,"By using hooks you can interact directly with the lifecycle of Fastify. There\nare Request/Reply hooks and application hooks:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#requestreply-hooks"},"Request/Reply Hooks"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#onrequest"},"onRequest")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#preparsing"},"preParsing")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#prevalidation"},"preValidation")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#prehandler"},"preHandler")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#preserialization"},"preSerialization")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#onerror"},"onError")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#onsend"},"onSend")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#onresponse"},"onResponse")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#ontimeout"},"onTimeout")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#manage-errors-from-a-hook"},"Manage Errors from a hook")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#respond-to-a-request-from-a-hook"},"Respond to a request from a hook")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#application-hooks"},"Application Hooks"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#onready"},"onReady")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#onclose"},"onClose")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#onroute"},"onRoute")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#onregister"},"onRegister")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#scope"},"Scope")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#route-level-hooks"},"Route level hooks")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#using-hooks-to-inject-custom-properties"},"Using Hooks to Inject Custom Properties")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#diagnostics-channel-hooks"},"Diagnostics Channel Hooks"))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Notice:")," the ",(0,o.kt)("inlineCode",{parentName:"p"},"done")," callback is not available when using ",(0,o.kt)("inlineCode",{parentName:"p"},"async"),"/",(0,o.kt)("inlineCode",{parentName:"p"},"await")," or\nreturning a ",(0,o.kt)("inlineCode",{parentName:"p"},"Promise"),". If you do invoke a ",(0,o.kt)("inlineCode",{parentName:"p"},"done")," callback in this situation\nunexpected behavior may occur, e.g. duplicate invocation of handlers."),(0,o.kt)("h2",{id:"requestreply-hooks"},"Request/Reply Hooks"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"/website-next/docs/v4.8.x/Reference/Request"},"Request")," and ",(0,o.kt)("a",{parentName:"p",href:"/website-next/docs/v4.8.x/Reference/Reply"},"Reply")," are the core Fastify objects."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"done")," is the function to continue with the ",(0,o.kt)("a",{parentName:"p",href:"/website-next/docs/v4.8.x/Reference/Lifecycle"},"lifecycle"),"."),(0,o.kt)("p",null,"It is easy to understand where each hook is executed by looking at the\n",(0,o.kt)("a",{parentName:"p",href:"/website-next/docs/v4.8.x/Reference/Lifecycle"},"lifecycle page"),"."),(0,o.kt)("p",null,"Hooks are affected by Fastify's encapsulation, and can thus be applied to\nselected routes. See the ",(0,o.kt)("a",{parentName:"p",href:"#scope"},"Scopes")," section for more information."),(0,o.kt)("p",null,"There are eight different hooks that you can use in Request/Reply ",(0,o.kt)("em",{parentName:"p"},"(in order of\nexecution)"),":"),(0,o.kt)("h3",{id:"onrequest"},"onRequest"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onRequest', (request, reply, done) => {\n  // Some code\n  done()\n})\n")),(0,o.kt)("p",null,"Or ",(0,o.kt)("inlineCode",{parentName:"p"},"async/await"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onRequest', async (request, reply) => {\n  // Some code\n  await asyncMethod()\n})\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Notice:")," in the ",(0,o.kt)("a",{parentName:"p",href:"#onrequest"},"onRequest")," hook, ",(0,o.kt)("inlineCode",{parentName:"p"},"request.body")," will always be\n",(0,o.kt)("inlineCode",{parentName:"p"},"undefined"),", because the body parsing happens before the\n",(0,o.kt)("a",{parentName:"p",href:"#prevalidation"},"preValidation")," hook."),(0,o.kt)("h3",{id:"preparsing"},"preParsing"),(0,o.kt)("p",null,"If you are using the ",(0,o.kt)("inlineCode",{parentName:"p"},"preParsing")," hook, you can transform the request payload\nstream before it is parsed. It receives the request and reply objects as other\nhooks, and a stream with the current request payload."),(0,o.kt)("p",null,"If it returns a value (via ",(0,o.kt)("inlineCode",{parentName:"p"},"return")," or via the callback function), it must\nreturn a stream."),(0,o.kt)("p",null,"For instance, you can uncompress the request body:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('preParsing', (request, reply, payload, done) => {\n  // Some code\n  done(null, newPayload)\n})\n")),(0,o.kt)("p",null,"Or ",(0,o.kt)("inlineCode",{parentName:"p"},"async/await"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('preParsing', async (request, reply, payload) => {\n  // Some code\n  await asyncMethod()\n  return newPayload\n})\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Notice:")," in the ",(0,o.kt)("a",{parentName:"p",href:"#preparsing"},"preParsing")," hook, ",(0,o.kt)("inlineCode",{parentName:"p"},"request.body")," will always be\n",(0,o.kt)("inlineCode",{parentName:"p"},"undefined"),", because the body parsing happens before the\n",(0,o.kt)("a",{parentName:"p",href:"#prevalidation"},"preValidation")," hook."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Notice:")," you should also add a ",(0,o.kt)("inlineCode",{parentName:"p"},"receivedEncodedLength")," property to the\nreturned stream. This property is used to correctly match the request payload\nwith the ",(0,o.kt)("inlineCode",{parentName:"p"},"Content-Length")," header value. Ideally, this property should be updated\non each received chunk."),(0,o.kt)("h3",{id:"prevalidation"},"preValidation"),(0,o.kt)("p",null,"If you are using the ",(0,o.kt)("inlineCode",{parentName:"p"},"preValidation")," hook, you can change the payload before it\nis validated. For example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('preValidation', (request, reply, done) => {\n  request.body = { ...request.body, importantKey: 'randomString' }\n  done()\n})\n")),(0,o.kt)("p",null,"Or ",(0,o.kt)("inlineCode",{parentName:"p"},"async/await"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('preValidation', async (request, reply) => {\n  const importantKey = await generateRandomString()\n  request.body = { ...request.body, importantKey }\n})\n")),(0,o.kt)("h3",{id:"prehandler"},"preHandler"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('preHandler', (request, reply, done) => {\n  // some code\n  done()\n})\n")),(0,o.kt)("p",null,"Or ",(0,o.kt)("inlineCode",{parentName:"p"},"async/await"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('preHandler', async (request, reply) => {\n  // Some code\n  await asyncMethod()\n})\n")),(0,o.kt)("h3",{id:"preserialization"},"preSerialization"),(0,o.kt)("p",null,"If you are using the ",(0,o.kt)("inlineCode",{parentName:"p"},"preSerialization")," hook, you can change (or replace) the\npayload before it is serialized. For example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('preSerialization', (request, reply, payload, done) => {\n  const err = null\n  const newPayload = { wrapped: payload }\n  done(err, newPayload)\n})\n")),(0,o.kt)("p",null,"Or ",(0,o.kt)("inlineCode",{parentName:"p"},"async/await"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('preSerialization', async (request, reply, payload) => {\n  return { wrapped: payload }\n})\n")),(0,o.kt)("p",null,"Note: the hook is NOT called if the payload is a ",(0,o.kt)("inlineCode",{parentName:"p"},"string"),", a ",(0,o.kt)("inlineCode",{parentName:"p"},"Buffer"),", a\n",(0,o.kt)("inlineCode",{parentName:"p"},"stream"),", or ",(0,o.kt)("inlineCode",{parentName:"p"},"null"),"."),(0,o.kt)("h3",{id:"onerror"},"onError"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onError', (request, reply, error, done) => {\n  // Some code\n  done()\n})\n")),(0,o.kt)("p",null,"Or ",(0,o.kt)("inlineCode",{parentName:"p"},"async/await"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onError', async (request, reply, error) => {\n  // Useful for custom error logging\n  // You should not use this hook to update the error\n})\n")),(0,o.kt)("p",null,"This hook is useful if you need to do some custom error logging or add some\nspecific header in case of error."),(0,o.kt)("p",null,"It is not intended for changing the error, and calling ",(0,o.kt)("inlineCode",{parentName:"p"},"reply.send")," will throw\nan exception."),(0,o.kt)("p",null,"This hook will be executed only after the ",(0,o.kt)("inlineCode",{parentName:"p"},"customErrorHandler")," has been\nexecuted, and only if the ",(0,o.kt)("inlineCode",{parentName:"p"},"customErrorHandler")," sends an error back to the user\n",(0,o.kt)("em",{parentName:"p"},"(Note that the default ",(0,o.kt)("inlineCode",{parentName:"em"},"customErrorHandler")," always sends the error back to the\nuser)"),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Notice:")," unlike the other hooks, passing an error to the ",(0,o.kt)("inlineCode",{parentName:"p"},"done")," function is not\nsupported."),(0,o.kt)("h3",{id:"onsend"},"onSend"),(0,o.kt)("p",null,"If you are using the ",(0,o.kt)("inlineCode",{parentName:"p"},"onSend")," hook, you can change the payload. For example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onSend', (request, reply, payload, done) => {\n  const err = null;\n  const newPayload = payload.replace('some-text', 'some-new-text')\n  done(err, newPayload)\n})\n")),(0,o.kt)("p",null,"Or ",(0,o.kt)("inlineCode",{parentName:"p"},"async/await"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onSend', async (request, reply, payload) => {\n  const newPayload = payload.replace('some-text', 'some-new-text')\n  return newPayload\n})\n")),(0,o.kt)("p",null,"You can also clear the payload to send a response with an empty body by\nreplacing the payload with ",(0,o.kt)("inlineCode",{parentName:"p"},"null"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onSend', (request, reply, payload, done) => {\n  reply.code(304)\n  const newPayload = null\n  done(null, newPayload)\n})\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"You can also send an empty body by replacing the payload with the empty string\n",(0,o.kt)("inlineCode",{parentName:"p"},"''"),", but be aware that this will cause the ",(0,o.kt)("inlineCode",{parentName:"p"},"Content-Length")," header to be set\nto ",(0,o.kt)("inlineCode",{parentName:"p"},"0"),", whereas the ",(0,o.kt)("inlineCode",{parentName:"p"},"Content-Length")," header will not be set if the payload is\n",(0,o.kt)("inlineCode",{parentName:"p"},"null"),".")),(0,o.kt)("p",null,"Note: If you change the payload, you may only change it to a ",(0,o.kt)("inlineCode",{parentName:"p"},"string"),", a\n",(0,o.kt)("inlineCode",{parentName:"p"},"Buffer"),", a ",(0,o.kt)("inlineCode",{parentName:"p"},"stream"),", or ",(0,o.kt)("inlineCode",{parentName:"p"},"null"),"."),(0,o.kt)("h3",{id:"onresponse"},"onResponse"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onResponse', (request, reply, done) => {\n  // Some code\n  done()\n})\n")),(0,o.kt)("p",null,"Or ",(0,o.kt)("inlineCode",{parentName:"p"},"async/await"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onResponse', async (request, reply) => {\n  // Some code\n  await asyncMethod()\n})\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"onResponse")," hook is executed when a response has been sent, so you will not\nbe able to send more data to the client. It can however be useful for sending\ndata to external services, for example, to gather statistics."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note:")," setting ",(0,o.kt)("inlineCode",{parentName:"p"},"disableRequestLogging")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," will disable any error log\ninside the ",(0,o.kt)("inlineCode",{parentName:"p"},"onResponse")," hook. In this case use ",(0,o.kt)("inlineCode",{parentName:"p"},"try - catch")," to log errors. "),(0,o.kt)("h3",{id:"ontimeout"},"onTimeout"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onTimeout', (request, reply, done) => {\n  // Some code\n  done()\n})\n")),(0,o.kt)("p",null,"Or ",(0,o.kt)("inlineCode",{parentName:"p"},"async/await"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onTimeout', async (request, reply) => {\n  // Some code\n  await asyncMethod()\n})\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"onTimeout")," is useful if you need to monitor the request timed out in your\nservice (if the ",(0,o.kt)("inlineCode",{parentName:"p"},"connectionTimeout")," property is set on the Fastify instance).\nThe ",(0,o.kt)("inlineCode",{parentName:"p"},"onTimeout")," hook is executed when a request is timed out and the HTTP socket\nhas been hanged up. Therefore, you will not be able to send data to the client."),(0,o.kt)("h3",{id:"manage-errors-from-a-hook"},"Manage Errors from a hook"),(0,o.kt)("p",null,"If you get an error during the execution of your hook, just pass it to ",(0,o.kt)("inlineCode",{parentName:"p"},"done()"),"\nand Fastify will automatically close the request and send the appropriate error\ncode to the user."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onRequest', (request, reply, done) => {\n  done(new Error('Some error'))\n})\n")),(0,o.kt)("p",null,"If you want to pass a custom error code to the user, just use ",(0,o.kt)("inlineCode",{parentName:"p"},"reply.code()"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('preHandler', (request, reply, done) => {\n  reply.code(400)\n  done(new Error('Some error'))\n})\n")),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"The error will be handled by ",(0,o.kt)("a",{parentName:"em",href:"/website-next/docs/v4.8.x/Reference/Reply#errors"},(0,o.kt)("inlineCode",{parentName:"a"},"Reply")),".")),(0,o.kt)("p",null,"Or if you're using ",(0,o.kt)("inlineCode",{parentName:"p"},"async/await")," you can just throw an error:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onRequest', async (request, reply) => {\n  throw new Error('Some error')\n})\n")),(0,o.kt)("h3",{id:"respond-to-a-request-from-a-hook"},"Respond to a request from a hook"),(0,o.kt)("p",null,"If needed, you can respond to a request before you reach the route handler, for\nexample when implementing an authentication hook. Replying from a hook implies\nthat the hook chain is ",(0,o.kt)("strong",{parentName:"p"},"stopped")," and the rest of the hooks and handlers are\nnot executed. If the hook is using the callback approach, i.e. it is not an\n",(0,o.kt)("inlineCode",{parentName:"p"},"async")," function or it returns a ",(0,o.kt)("inlineCode",{parentName:"p"},"Promise"),", it is as simple as calling\n",(0,o.kt)("inlineCode",{parentName:"p"},"reply.send()")," and avoiding calling the callback. If the hook is ",(0,o.kt)("inlineCode",{parentName:"p"},"async"),",\n",(0,o.kt)("inlineCode",{parentName:"p"},"reply.send()")," ",(0,o.kt)("strong",{parentName:"p"},"must")," be called ",(0,o.kt)("em",{parentName:"p"},"before")," the function returns or the promise\nresolves, otherwise, the request will proceed. When ",(0,o.kt)("inlineCode",{parentName:"p"},"reply.send()")," is called\noutside of the promise chain, it is important to ",(0,o.kt)("inlineCode",{parentName:"p"},"return reply")," otherwise the\nrequest will be executed twice."),(0,o.kt)("p",null,"It is important to ",(0,o.kt)("strong",{parentName:"p"},"not mix callbacks and ",(0,o.kt)("inlineCode",{parentName:"strong"},"async"),"/",(0,o.kt)("inlineCode",{parentName:"strong"},"Promise")),", otherwise the\nhook chain will be executed twice."),(0,o.kt)("p",null,"If you are using ",(0,o.kt)("inlineCode",{parentName:"p"},"onRequest")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"preHandler")," use ",(0,o.kt)("inlineCode",{parentName:"p"},"reply.send"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onRequest', (request, reply, done) => {\n  reply.send('Early response')\n})\n\n// Works with async functions too\nfastify.addHook('preHandler', async (request, reply) => {\n  await something()\n  reply.send({ hello: 'world' })\n  return reply // mandatory, so the request is not executed further\n})\n")),(0,o.kt)("p",null,"If you want to respond with a stream, you should avoid using an ",(0,o.kt)("inlineCode",{parentName:"p"},"async")," function\nfor the hook. If you must use an ",(0,o.kt)("inlineCode",{parentName:"p"},"async")," function, your code will need to follow\nthe pattern in\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/fastify/fastify/blob/94ea67ef2d8dce8a955d510cd9081aabd036fa85/test/hooks-async.js#L269-L275"},"test/hooks-async.js"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onRequest', (request, reply, done) => {\n  const stream = fs.createReadStream('some-file', 'utf8')\n  reply.send(stream)\n})\n")),(0,o.kt)("p",null,"If you are sending a response without ",(0,o.kt)("inlineCode",{parentName:"p"},"await")," on it, make sure to always ",(0,o.kt)("inlineCode",{parentName:"p"},"return\nreply"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('preHandler', async (request, reply) => {\n  setImmediate(() => { reply.send('hello') })\n\n  // This is needed to signal the handler to wait for a response\n  // to be sent outside of the promise chain\n  return reply\n})\n\nfastify.addHook('preHandler', async (request, reply) => {\n  // the @fastify/static plugin will send a file asynchronously,\n  // so we should return reply\n  reply.sendFile('myfile')\n  return reply\n})\n")),(0,o.kt)("h2",{id:"application-hooks"},"Application Hooks"),(0,o.kt)("p",null,"You can hook into the application-lifecycle as well."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#onready"},"onReady")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#onclose"},"onClose")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#onroute"},"onRoute")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#onregister"},"onRegister"))),(0,o.kt)("h3",{id:"onready"},"onReady"),(0,o.kt)("p",null,"Triggered before the server starts listening for requests and when ",(0,o.kt)("inlineCode",{parentName:"p"},".ready()")," is\ninvoked. It cannot change the routes or add new hooks. Registered hook functions\nare executed serially. Only after all ",(0,o.kt)("inlineCode",{parentName:"p"},"onReady")," hook functions have completed\nwill the server start listening for requests. Hook functions accept one\nargument: a callback, ",(0,o.kt)("inlineCode",{parentName:"p"},"done"),", to be invoked after the hook function is complete.\nHook functions are invoked with ",(0,o.kt)("inlineCode",{parentName:"p"},"this")," bound to the associated Fastify instance."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"// callback style\nfastify.addHook('onReady', function (done) {\n  // Some code\n  const err = null;\n  done(err)\n})\n\n// or async/await style\nfastify.addHook('onReady', async function () {\n  // Some async code\n  await loadCacheFromDatabase()\n})\n")),(0,o.kt)("h3",{id:"onclose"},"onClose"),(0,o.kt)("a",{id:"on-close"}),(0,o.kt)("p",null,"Triggered when ",(0,o.kt)("inlineCode",{parentName:"p"},"fastify.close()")," is invoked to stop the server. It is useful\nwhen ",(0,o.kt)("a",{parentName:"p",href:"/website-next/docs/v4.8.x/Reference/Plugins"},"plugins"),' need a "shutdown" event, for example, to close an\nopen connection to a database.'),(0,o.kt)("p",null,"The hook function takes the Fastify instance as a first argument,\nand a ",(0,o.kt)("inlineCode",{parentName:"p"},"done")," callback for synchronous hook functions."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"// callback style\nfastify.addHook('onClose', (instance, done) => {\n  // Some code\n  done()\n})\n\n// or async/await style\nfastify.addHook('onClose', async (instance) => {\n  // Some async code\n  await closeDatabaseConnections()\n})\n")),(0,o.kt)("h3",{id:"onroute"},"onRoute"),(0,o.kt)("a",{id:"on-route"}),(0,o.kt)("p",null,"Triggered when a new route is registered. Listeners are passed a ",(0,o.kt)("inlineCode",{parentName:"p"},"routeOptions"),"\nobject as the sole parameter. The interface is synchronous, and, as such, the\nlisteners are not passed a callback. This hook is encapsulated."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onRoute', (routeOptions) => {\n  //Some code\n  routeOptions.method\n  routeOptions.schema\n  routeOptions.url // the complete URL of the route, it will include the prefix if any\n  routeOptions.path // `url` alias\n  routeOptions.routePath // the URL of the route without the prefix\n  routeOptions.bodyLimit\n  routeOptions.logLevel\n  routeOptions.logSerializers\n  routeOptions.prefix\n})\n")),(0,o.kt)("p",null,"If you are authoring a plugin and you need to customize application routes, like\nmodifying the options or adding new route hooks, this is the right place."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onRoute', (routeOptions) => {\n  function onPreSerialization(request, reply, payload, done) {\n    // Your code\n    done(null, payload)\n  }\n  // preSerialization can be an array or undefined\n  routeOptions.preSerialization = [...(routeOptions.preSerialization || []), onPreSerialization]\n})\n")),(0,o.kt)("p",null,"If you want to add more routes within an onRoute hook, you have to tag these\nroutes properly. If you don't, the hook will run into an infinite loop. The\nrecommended approach is shown below."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const kRouteAlreadyProcessed = Symbol('route-already-processed')\n\nfastify.addHook('onRoute', function (routeOptions) {\n  const { url, method } = routeOptions\n\n  const isAlreadyProcessed = (routeOptions.custom && routeOptions.custom[kRouteAlreadyProcessed]) || false\n\n  if (!isAlreadyProcessed) {\n    this.route({\n      url,\n      method,\n      custom: {\n        [kRouteAlreadyProcessed]: true\n      },\n      handler: () => {}\n    })\n  }\n})\n")),(0,o.kt)("p",null,"For more details, see this ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/fastify/fastify/issues/4319"},"issue"),"."),(0,o.kt)("h3",{id:"onregister"},"onRegister"),(0,o.kt)("a",{id:"on-register"}),(0,o.kt)("p",null,"Triggered when a new plugin is registered and a new encapsulation context is\ncreated. The hook will be executed ",(0,o.kt)("strong",{parentName:"p"},"before")," the registered code."),(0,o.kt)("p",null,"This hook can be useful if you are developing a plugin that needs to know when a\nplugin context is formed, and you want to operate in that specific context, thus\nthis hook is encapsulated."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note:")," This hook will not be called if a plugin is wrapped inside\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/fastify/fastify-plugin"},(0,o.kt)("inlineCode",{parentName:"a"},"fastify-plugin")),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.decorate('data', [])\n\nfastify.register(async (instance, opts) => {\n  instance.data.push('hello')\n  console.log(instance.data) // ['hello']\n\n  instance.register(async (instance, opts) => {\n    instance.data.push('world')\n    console.log(instance.data) // ['hello', 'world']\n  }, { prefix: '/hola' })\n}, { prefix: '/ciao' })\n\nfastify.register(async (instance, opts) => {\n  console.log(instance.data) // []\n}, { prefix: '/hello' })\n\nfastify.addHook('onRegister', (instance, opts) => {\n  // Create a new array from the old one\n  // but without keeping the reference\n  // allowing the user to have encapsulated\n  // instances of the `data` property\n  instance.data = instance.data.slice()\n\n  // the options of the new registered instance\n  console.log(opts.prefix)\n})\n")),(0,o.kt)("h2",{id:"scope"},"Scope"),(0,o.kt)("a",{id:"scope"}),(0,o.kt)("p",null,"Except for ",(0,o.kt)("a",{parentName:"p",href:"#onclose"},"onClose"),", all hooks are encapsulated. This means that you\ncan decide where your hooks should run by using ",(0,o.kt)("inlineCode",{parentName:"p"},"register")," as explained in the\n",(0,o.kt)("a",{parentName:"p",href:"/website-next/docs/v4.8.x/Guides/Plugins-Guide"},"plugins guide"),". If you pass a function, that\nfunction is bound to the right Fastify context and from there you have full\naccess to the Fastify API."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onRequest', function (request, reply, done) {\n  const self = this // Fastify context\n  done()\n})\n")),(0,o.kt)("p",null,"Note that the Fastify context in each hook is the same as the plugin where the\nroute was registered, for example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onRequest', async function (req, reply) {\n  if (req.raw.url === '/nested') {\n    assert.strictEqual(this.foo, 'bar')\n  } else {\n    assert.strictEqual(this.foo, undefined)\n  }\n})\n\nfastify.get('/', async function (req, reply) {\n  assert.strictEqual(this.foo, undefined)\n  return { hello: 'world' }\n})\n\nfastify.register(async function plugin (fastify, opts) {\n  fastify.decorate('foo', 'bar')\n\n  fastify.get('/nested', async function (req, reply) {\n    assert.strictEqual(this.foo, 'bar')\n    return { hello: 'world' }\n  })\n})\n")),(0,o.kt)("p",null,"Warn: if you declare the function with an ",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions"},"arrow\nfunction"),",\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"this")," will not be Fastify, but the one of the current scope."),(0,o.kt)("h2",{id:"route-level-hooks"},"Route level hooks"),(0,o.kt)("a",{id:"route-hooks"}),(0,o.kt)("p",null,"You can declare one or more custom lifecycle hooks (",(0,o.kt)("a",{parentName:"p",href:"#onrequest"},"onRequest"),",\n",(0,o.kt)("a",{parentName:"p",href:"#onresponse"},"onResponse"),", ",(0,o.kt)("a",{parentName:"p",href:"#preparsing"},"preParsing"),",\n",(0,o.kt)("a",{parentName:"p",href:"#prevalidation"},"preValidation"),", ",(0,o.kt)("a",{parentName:"p",href:"#prehandler"},"preHandler"),",\n",(0,o.kt)("a",{parentName:"p",href:"#preserialization"},"preSerialization"),", ",(0,o.kt)("a",{parentName:"p",href:"#onsend"},"onSend"),",\n",(0,o.kt)("a",{parentName:"p",href:"#ontimeout"},"onTimeout"),", and ",(0,o.kt)("a",{parentName:"p",href:"#onerror"},"onError"),") hook(s) that will be\n",(0,o.kt)("strong",{parentName:"p"},"unique")," for the route. If you do so, those hooks are always executed as the\nlast hook in their category."),(0,o.kt)("p",null,"This can be useful if you need to implement authentication, where the\n",(0,o.kt)("a",{parentName:"p",href:"#preparsing"},"preParsing")," or ",(0,o.kt)("a",{parentName:"p",href:"#prevalidation"},"preValidation")," hooks are exactly\nwhat you need. Multiple route-level hooks can also be specified as an array."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onRequest', (request, reply, done) => {\n  // Your code\n  done()\n})\n\nfastify.addHook('onResponse', (request, reply, done) => {\n  // your code\n  done()\n})\n\nfastify.addHook('preParsing', (request, reply, done) => {\n  // Your code\n  done()\n})\n\nfastify.addHook('preValidation', (request, reply, done) => {\n  // Your code\n  done()\n})\n\nfastify.addHook('preHandler', (request, reply, done) => {\n  // Your code\n  done()\n})\n\nfastify.addHook('preSerialization', (request, reply, payload, done) => {\n  // Your code\n  done(null, payload)\n})\n\nfastify.addHook('onSend', (request, reply, payload, done) => {\n  // Your code\n  done(null, payload)\n})\n\nfastify.addHook('onTimeout', (request, reply, done) => {\n  // Your code\n  done()\n})\n\nfastify.addHook('onError', (request, reply, error, done) => {\n  // Your code\n  done()\n})\n\nfastify.route({\n  method: 'GET',\n  url: '/',\n  schema: { ... },\n  onRequest: function (request, reply, done) {\n    // This hook will always be executed after the shared `onRequest` hooks\n    done()\n  },\n  onResponse: function (request, reply, done) {\n    // this hook will always be executed after the shared `onResponse` hooks\n    done()\n  },\n  preParsing: function (request, reply, done) {\n    // This hook will always be executed after the shared `preParsing` hooks\n    done()\n  },\n  preValidation: function (request, reply, done) {\n    // This hook will always be executed after the shared `preValidation` hooks\n    done()\n  },\n  preHandler: function (request, reply, done) {\n    // This hook will always be executed after the shared `preHandler` hooks\n    done()\n  },\n  // // Example with an array. All hooks support this syntax.\n  //\n  // preHandler: [function (request, reply, done) {\n  //   // This hook will always be executed after the shared `preHandler` hooks\n  //   done()\n  // }],\n  preSerialization: (request, reply, payload, done) => {\n    // This hook will always be executed after the shared `preSerialization` hooks\n    done(null, payload)\n  },\n  onSend: (request, reply, payload, done) => {\n    // This hook will always be executed after the shared `onSend` hooks\n    done(null, payload)\n  },\n  onTimeout: (request, reply, done) => {\n    // This hook will always be executed after the shared `onTimeout` hooks\n    done()\n  },\n  onError: (request, reply, error, done) => {\n    // This hook will always be executed after the shared `onError` hooks\n    done()\n  },\n  handler: function (request, reply) {\n    reply.send({ hello: 'world' })\n  }\n})\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note"),": both options also accept an array of functions."),(0,o.kt)("h2",{id:"using-hooks-to-inject-custom-properties"},"Using Hooks to Inject Custom Properties"),(0,o.kt)("a",{id:"using-hooks-to-inject-custom-properties"}),(0,o.kt)("p",null,"You can use a hook to inject custom properties into incoming requests.\nThis is useful for reusing processed data from hooks in controllers."),(0,o.kt)("p",null,"A very common use case is, for example, checking user authentication based\non their token and then storing their recovered data into\nthe ",(0,o.kt)("a",{parentName:"p",href:"/website-next/docs/v4.8.x/Reference/Request"},"Request")," instance. This way, your controllers can read it\neasily with ",(0,o.kt)("inlineCode",{parentName:"p"},"request.authenticatedUser")," or whatever you want to call it.\nThat's how it might look like:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('preParsing', async (request) => {\n  request.authenticatedUser = {\n    id: 42,\n    name: 'Jane Doe',\n    role: 'admin'\n  }\n})\n\nfastify.get('/me/is-admin', async function (req, reply) {\n  return { isAdmin: req.authenticatedUser?.role === 'admin' || false }\n})\n")),(0,o.kt)("p",null,"Note that ",(0,o.kt)("inlineCode",{parentName:"p"},".authenticatedUser")," could actually be any property name\nchoosen by yourself. Using your own custom property prevents you\nfrom mutating existing properties, which\nwould be a dangerous and destructive operation. So be careful and\nmake sure your property is entirely new, also using this approach\nonly for very specific and small cases like this example."),(0,o.kt)("p",null,"Regarding TypeScript in this example, you'd need to update the\n",(0,o.kt)("inlineCode",{parentName:"p"},"FastifyRequest")," core interface to include your new property typing\n(for more about it, see ",(0,o.kt)("a",{parentName:"p",href:"/website-next/docs/v4.8.x/Reference/TypeScript"},"TypeScript")," page), like:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"interface AuthenticatedUser { /* ... */ }\n\ndeclare module 'fastify' {\n  export interface FastifyRequest {\n    authenticatedUser?: AuthenticatedUser;\n  }\n}\n")),(0,o.kt)("p",null,"Although this is a very pragmatic approach, if you're trying to do\nsomething more complex that changes these core objects, then\nconsider creating a custom ",(0,o.kt)("a",{parentName:"p",href:"/website-next/docs/v4.8.x/Reference/Plugins"},"Plugin")," instead."),(0,o.kt)("h2",{id:"diagnostics-channel-hooks"},"Diagnostics Channel Hooks"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Note:")," The ",(0,o.kt)("inlineCode",{parentName:"p"},"diagnostics_channel")," is currently experimental on Node.js, so\nits API is subject to change even in semver-patch releases of Node.js. For\nversions of Node.js supported by Fastify where ",(0,o.kt)("inlineCode",{parentName:"p"},"diagnostics_channel")," is\nunavailable, the hook will use the\n",(0,o.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/diagnostics_channel"},"polyfill")," if it is\navailable. Otherwise, this feature will not be present.")),(0,o.kt)("p",null,"Currently, one\n",(0,o.kt)("a",{parentName:"p",href:"https://nodejs.org/api/diagnostics_channel.html"},(0,o.kt)("inlineCode",{parentName:"a"},"diagnostics_channel"))," publish\nevent, ",(0,o.kt)("inlineCode",{parentName:"p"},"'fastify.initialization'"),", happens at initialization time. The Fastify\ninstance is passed into the hook as a property of the object passed in. At this\npoint, the instance can be interacted with to add hooks, plugins, routes, or any\nother sort of modification."),(0,o.kt)("p",null,'For example, a tracing package might do something like the following (which is,\nof course, a simplification). This would be in a file loaded in the\ninitialization of the tracking package, in the typical "require instrumentation\ntools first" fashion.'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const tracer = /* retrieved from elsehwere in the package */\nconst dc = require('diagnostics_channel')\nconst channel = dc.channel('fastify.initialization')\nconst spans = new WeakMap()\n\nchannel.subscribe(function ({ fastify }) {\n  fastify.addHook('onRequest', (request, reply, done) => {\n    const span = tracer.startSpan('fastify.request')\n    spans.set(request, span)\n    done()\n  })\n\n  fastify.addHook('onResponse', (request, reply, done) => {\n    const span = spans.get(request)\n    span.finish()\n    done()\n  })\n})\n")))}u.isMDXComponent=!0}}]);