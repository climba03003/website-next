"use strict";(self.webpackChunkfastify_website=self.webpackChunkfastify_website||[]).push([[2032],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return h}});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},d=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=p(t),h=o,k=c["".concat(s,".").concat(h)]||c[h]||u[h]||r;return t?a.createElement(k,i(i({ref:n},d),{},{components:t})):a.createElement(k,i({ref:n},d))}));function h(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,i=new Array(r);i[0]=c;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var p=2;p<r;p++)i[p]=t[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},3335:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return d},default:function(){return c}});var a=t(7462),o=t(3366),r=(t(7294),t(3905)),i=["components"],l={title:"Hooks",sidebar_label:"Hooks",hide_title:!1},s=void 0,p={unversionedId:"Hooks",id:"Hooks",isDocsHomePage:!1,title:"Hooks",description:"Hooks are registered with the fastify.addHook method and allow you to listen to specific events in the application or request/response lifecycle. You have to register a hook before the event is triggered, otherwise, the event is lost.",source:"@site/docs/Hooks.md",sourceDirName:".",slug:"/Hooks",permalink:"/website-next/docs/v3/Hooks",editUrl:"https://github.com/fastify/website-next/edit/main/docs/docs/Hooks.md",tags:[],version:"current",frontMatter:{title:"Hooks",sidebar_label:"Hooks",hide_title:!1},sidebar:"sidebar",previous:{title:"HTTP2",permalink:"/website-next/docs/v3/HTTP2"},next:{title:"Long Term Support",permalink:"/website-next/docs/v3/LTS"}},d=[{value:"Request/Reply Hooks",id:"requestreply-hooks",children:[{value:"onRequest",id:"onrequest",children:[],level:3},{value:"preParsing",id:"preparsing",children:[],level:3},{value:"preValidation",id:"prevalidation",children:[],level:3},{value:"preHandler",id:"prehandler",children:[],level:3},{value:"preSerialization",id:"preserialization",children:[],level:3},{value:"onError",id:"onerror",children:[],level:3},{value:"onSend",id:"onsend",children:[],level:3},{value:"onResponse",id:"onresponse",children:[],level:3},{value:"onTimeout",id:"ontimeout",children:[],level:3},{value:"Manage Errors from a hook",id:"manage-errors-from-a-hook",children:[],level:3},{value:"Respond to a request from a hook",id:"respond-to-a-request-from-a-hook",children:[],level:3}],level:2},{value:"Application Hooks",id:"application-hooks",children:[{value:"onReady",id:"onready",children:[],level:3},{value:"onClose",id:"onclose",children:[],level:3},{value:"onRoute",id:"onroute",children:[],level:3},{value:"onRegister",id:"onregister",children:[],level:3}],level:2},{value:"Scope",id:"scope",children:[],level:2},{value:"Route level hooks",id:"route-level-hooks",children:[],level:2},{value:"Diagnostics Channel Hooks",id:"diagnostics-channel-hooks",children:[],level:2}],u={toc:d};function c(e){var n=e.components,t=(0,o.Z)(e,i);return(0,r.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Hooks are registered with the ",(0,r.kt)("inlineCode",{parentName:"p"},"fastify.addHook")," method and allow you to listen to specific events in the application or request/response lifecycle. You have to register a hook before the event is triggered, otherwise, the event is lost."),(0,r.kt)("p",null,"By using hooks you can interact directly with the lifecycle of Fastify. There are Request/Reply hooks and application hooks:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#requestreply-hooks"},"Request/Reply Hooks"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#onrequest"},"onRequest")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#preparsing"},"preParsing")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#prevalidation"},"preValidation")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#prehandler"},"preHandler")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#preserialization"},"preSerialization")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#onerror"},"onError")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#onsend"},"onSend")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#onresponse"},"onResponse")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#ontimeout"},"onTimeout")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#manage-errors-from-a-hook"},"Manage Errors from a hook")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#respond-to-a-request-from-a-hook"},"Respond to a request from a hook")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#application-hooks"},"Application Hooks"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#onready"},"onReady")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#onclose"},"onClose")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#onroute"},"onRoute")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#onregister"},"onRegister")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#scope"},"Scope")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#route-level-hooks"},"Route level hooks")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#diagnostics-channel-hooks"},"Diagnostics Channel Hooks"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Notice:")," the ",(0,r.kt)("inlineCode",{parentName:"p"},"done")," callback is not available when using ",(0,r.kt)("inlineCode",{parentName:"p"},"async"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"await")," or returning a ",(0,r.kt)("inlineCode",{parentName:"p"},"Promise"),". If you do invoke a ",(0,r.kt)("inlineCode",{parentName:"p"},"done")," callback in this situation unexpected behavior may occur, e.g. duplicate invocation of handlers."),(0,r.kt)("h2",{id:"requestreply-hooks"},"Request/Reply Hooks"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"/website-next/docs/v3/Request"},"Request")," and ",(0,r.kt)("a",{parentName:"p",href:"/website-next/docs/v3/Reply"},"Reply")," are the core Fastify objects."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"done")," is the function to continue with the ",(0,r.kt)("a",{parentName:"p",href:"/website-next/docs/v3/Lifecycle"},"lifecycle"),"."),(0,r.kt)("p",null,"It is easy to understand where each hook is executed by looking at the ",(0,r.kt)("a",{parentName:"p",href:"/website-next/docs/v3/Lifecycle"},"lifecycle page"),"."),(0,r.kt)("p",null,"Hooks are affected by Fastify's encapsulation, and can thus be applied to selected routes. See the ",(0,r.kt)("a",{parentName:"p",href:"#scope"},"Scopes")," section for more information."),(0,r.kt)("p",null,"There are eight different hooks that you can use in Request/Reply ",(0,r.kt)("em",{parentName:"p"},"(in order of execution)"),":"),(0,r.kt)("h3",{id:"onrequest"},"onRequest"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onRequest', (request, reply, done) => {\n  // Some code\n  done()\n})\n")),(0,r.kt)("p",null,"Or ",(0,r.kt)("inlineCode",{parentName:"p"},"async/await"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onRequest', async (request, reply) => {\n  // Some code\n  await asyncMethod()\n})\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Notice:")," in the ",(0,r.kt)("a",{parentName:"p",href:"#onrequest"},"onRequest")," hook, ",(0,r.kt)("inlineCode",{parentName:"p"},"request.body")," will always be ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", because the body parsing happens before the ",(0,r.kt)("a",{parentName:"p",href:"#prevalidation"},"preValidation")," hook."),(0,r.kt)("h3",{id:"preparsing"},"preParsing"),(0,r.kt)("p",null,"If you are using the ",(0,r.kt)("inlineCode",{parentName:"p"},"preParsing")," hook, you can transform the request payload stream before it is parsed. It receives the request and reply objects as other hooks, and a stream with the current request payload."),(0,r.kt)("p",null,"If it returns a value (via ",(0,r.kt)("inlineCode",{parentName:"p"},"return")," or via the callback function), it must return a stream."),(0,r.kt)("p",null,"For instance, you can uncompress the request body:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('preParsing', (request, reply, payload, done) => {\n  // Some code\n  done(null, newPayload)\n})\n")),(0,r.kt)("p",null,"Or ",(0,r.kt)("inlineCode",{parentName:"p"},"async/await"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('preParsing', async (request, reply, payload) => {\n  // Some code\n  await asyncMethod()\n  return newPayload\n})\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Notice:")," in the ",(0,r.kt)("a",{parentName:"p",href:"#preparsing"},"preParsing")," hook, ",(0,r.kt)("inlineCode",{parentName:"p"},"request.body")," will always be ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", because the body parsing happens before the ",(0,r.kt)("a",{parentName:"p",href:"#prevalidation"},"preValidation")," hook."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Notice:")," you should also add a ",(0,r.kt)("inlineCode",{parentName:"p"},"receivedEncodedLength")," property to the returned stream. This property is used to correctly match the request payload with the ",(0,r.kt)("inlineCode",{parentName:"p"},"Content-Length")," header value. Ideally, this property should be updated on each received chunk."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Notice"),": The old syntaxes ",(0,r.kt)("inlineCode",{parentName:"p"},"function(request, reply, done)")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"async function(request, reply)")," for the parser are still supported but they are deprecated."),(0,r.kt)("h3",{id:"prevalidation"},"preValidation"),(0,r.kt)("p",null,"If you are using the ",(0,r.kt)("inlineCode",{parentName:"p"},"preValidation")," hook, you can change the payload before it is validated. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('preValidation', (request, reply, done) => {\n  request.body = { ...request.body, importantKey: 'randomString' }\n  done()\n})\n")),(0,r.kt)("p",null,"Or ",(0,r.kt)("inlineCode",{parentName:"p"},"async/await"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('preValidation', async (request, reply) => {\n  const importantKey = await generateRandomString()\n  request.body = { ...request.body, importantKey }\n})\n")),(0,r.kt)("h3",{id:"prehandler"},"preHandler"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('preHandler', (request, reply, done) => {\n  // some code\n  done()\n})\n")),(0,r.kt)("p",null,"Or ",(0,r.kt)("inlineCode",{parentName:"p"},"async/await"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('preHandler', async (request, reply) => {\n  // Some code\n  await asyncMethod()\n})\n")),(0,r.kt)("h3",{id:"preserialization"},"preSerialization"),(0,r.kt)("p",null,"If you are using the ",(0,r.kt)("inlineCode",{parentName:"p"},"preSerialization")," hook, you can change (or replace) the payload before it is serialized. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('preSerialization', (request, reply, payload, done) => {\n  const err = null\n  const newPayload = { wrapped: payload }\n  done(err, newPayload)\n})\n")),(0,r.kt)("p",null,"Or ",(0,r.kt)("inlineCode",{parentName:"p"},"async/await"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('preSerialization', async (request, reply, payload) => {\n  return { wrapped: payload }\n})\n")),(0,r.kt)("p",null,"Note: the hook is NOT called if the payload is a ",(0,r.kt)("inlineCode",{parentName:"p"},"string"),", a ",(0,r.kt)("inlineCode",{parentName:"p"},"Buffer"),", a ",(0,r.kt)("inlineCode",{parentName:"p"},"stream"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),"."),(0,r.kt)("h3",{id:"onerror"},"onError"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onError', (request, reply, error, done) => {\n  // Some code\n  done()\n})\n")),(0,r.kt)("p",null,"Or ",(0,r.kt)("inlineCode",{parentName:"p"},"async/await"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onError', async (request, reply, error) => {\n  // Useful for custom error logging\n  // You should not use this hook to update the error\n})\n")),(0,r.kt)("p",null,"This hook is useful if you need to do some custom error logging or add some specific header in case of error."),(0,r.kt)("p",null,"It is not intended for changing the error, and calling ",(0,r.kt)("inlineCode",{parentName:"p"},"reply.send")," will throw an exception."),(0,r.kt)("p",null,"This hook will be executed only after the ",(0,r.kt)("inlineCode",{parentName:"p"},"customErrorHandler")," has been executed, and only if the ",(0,r.kt)("inlineCode",{parentName:"p"},"customErrorHandler")," sends an error back to the user ",(0,r.kt)("em",{parentName:"p"},"(Note that the default ",(0,r.kt)("inlineCode",{parentName:"em"},"customErrorHandler")," always sends the error back to the user)"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Notice:")," unlike the other hooks, pass an error to the ",(0,r.kt)("inlineCode",{parentName:"p"},"done")," function is not supported."),(0,r.kt)("h3",{id:"onsend"},"onSend"),(0,r.kt)("p",null,"If you are using the ",(0,r.kt)("inlineCode",{parentName:"p"},"onSend")," hook, you can change the payload. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onSend', (request, reply, payload, done) => {\n  const err = null;\n  const newPayload = payload.replace('some-text', 'some-new-text')\n  done(err, newPayload)\n})\n")),(0,r.kt)("p",null,"Or ",(0,r.kt)("inlineCode",{parentName:"p"},"async/await"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onSend', async (request, reply, payload) => {\n  const newPayload = payload.replace('some-text', 'some-new-text')\n  return newPayload\n})\n")),(0,r.kt)("p",null,"You can also clear the payload to send a response with an empty body by replacing the payload with ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onSend', (request, reply, payload, done) => {\n  reply.code(304)\n  const newPayload = null\n  done(null, newPayload)\n})\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"You can also send an empty body by replacing the payload with the empty string ",(0,r.kt)("inlineCode",{parentName:"p"},"''"),", but be aware that this will cause the ",(0,r.kt)("inlineCode",{parentName:"p"},"Content-Length")," header to be set to ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),", whereas the ",(0,r.kt)("inlineCode",{parentName:"p"},"Content-Length")," header will not be set if the payload is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),".")),(0,r.kt)("p",null,"Note: If you change the payload, you may only change it to a ",(0,r.kt)("inlineCode",{parentName:"p"},"string"),", a ",(0,r.kt)("inlineCode",{parentName:"p"},"Buffer"),", a ",(0,r.kt)("inlineCode",{parentName:"p"},"stream"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),"."),(0,r.kt)("h3",{id:"onresponse"},"onResponse"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onResponse', (request, reply, done) => {\n  // Some code\n  done()\n})\n")),(0,r.kt)("p",null,"Or ",(0,r.kt)("inlineCode",{parentName:"p"},"async/await"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onResponse', async (request, reply) => {\n  // Some code\n  await asyncMethod()\n})\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"onResponse")," hook is executed when a response has been sent, so you will not be able to send more data to the client. It can however be useful for sending data to external services, for example, to gather statistics."),(0,r.kt)("h3",{id:"ontimeout"},"onTimeout"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onTimeout', (request, reply, done) => {\n  // Some code\n  done()\n})\n")),(0,r.kt)("p",null,"Or ",(0,r.kt)("inlineCode",{parentName:"p"},"async/await"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onTimeout', async (request, reply) => {\n  // Some code\n  await asyncMethod()\n})\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"onTimeout")," is useful if you need to monitor the request timed out in your service (if the ",(0,r.kt)("inlineCode",{parentName:"p"},"connectionTimeout")," property is set on the Fastify instance). The ",(0,r.kt)("inlineCode",{parentName:"p"},"onTimeout")," hook is executed when a request is timed out and the HTTP socket has been hanged up. Therefore, you will not be able to send data to the client."),(0,r.kt)("h3",{id:"manage-errors-from-a-hook"},"Manage Errors from a hook"),(0,r.kt)("p",null,"If you get an error during the execution of your hook, just pass it to ",(0,r.kt)("inlineCode",{parentName:"p"},"done()")," and Fastify will automatically close the request and send the appropriate error code to the user."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onRequest', (request, reply, done) => {\n  done(new Error('Some error'))\n})\n")),(0,r.kt)("p",null,"If you want to pass a custom error code to the user, just use ",(0,r.kt)("inlineCode",{parentName:"p"},"reply.code()"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('preHandler', (request, reply, done) => {\n  reply.code(400)\n  done(new Error('Some error'))\n})\n")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"The error will be handled by ",(0,r.kt)("a",{parentName:"em",href:"/website-next/docs/v3/Reply#errors"},(0,r.kt)("inlineCode",{parentName:"a"},"Reply")),".")),(0,r.kt)("p",null,"Or if you're using ",(0,r.kt)("inlineCode",{parentName:"p"},"async/await")," you can just throw an error:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onResponse', async (request, reply) => {\n  throw new Error('Some error')\n})\n")),(0,r.kt)("h3",{id:"respond-to-a-request-from-a-hook"},"Respond to a request from a hook"),(0,r.kt)("p",null,"If needed, you can respond to a request before you reach the route handler,\nfor example when implementing an authentication hook.\nReplying from a hook implies that the hook chain is ",(0,r.kt)("strong",{parentName:"p"},"stopped")," and\nthe rest of the hooks and handlers are not executed. If the hook is\nusing the callback approach, i.e. it is not an ",(0,r.kt)("inlineCode",{parentName:"p"},"async")," function or it\nreturns a ",(0,r.kt)("inlineCode",{parentName:"p"},"Promise"),", it is as simple as calling ",(0,r.kt)("inlineCode",{parentName:"p"},"reply.send()")," and avoiding\ncalling the callback. If the hook is ",(0,r.kt)("inlineCode",{parentName:"p"},"async"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"reply.send()")," ",(0,r.kt)("strong",{parentName:"p"},"must")," be\ncalled ",(0,r.kt)("em",{parentName:"p"},"before")," the function returns or the promise resolves, otherwise, the\nrequest will proceed. When ",(0,r.kt)("inlineCode",{parentName:"p"},"reply.send()")," is called outside of the\npromise chain, it is important to ",(0,r.kt)("inlineCode",{parentName:"p"},"return reply")," otherwise the request\nwill be executed twice."),(0,r.kt)("p",null,"It is important to ",(0,r.kt)("strong",{parentName:"p"},"not mix callbacks and ",(0,r.kt)("inlineCode",{parentName:"strong"},"async"),"/",(0,r.kt)("inlineCode",{parentName:"strong"},"Promise")),", otherwise\nthe hook chain will be executed twice."),(0,r.kt)("p",null,"If you are using ",(0,r.kt)("inlineCode",{parentName:"p"},"onRequest")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"preHandler")," use ",(0,r.kt)("inlineCode",{parentName:"p"},"reply.send"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onRequest', (request, reply, done) => {\n  reply.send('Early response')\n})\n\n// Works with async functions too\nfastify.addHook('preHandler', async (request, reply) => {\n  await something()\n  reply.send({ hello: 'world' })\n  return reply // optional in this case, but it is a good practice\n})\n")),(0,r.kt)("p",null,"If you want to respond with a stream, you should avoid using an ",(0,r.kt)("inlineCode",{parentName:"p"},"async")," function for the hook. If you must use an ",(0,r.kt)("inlineCode",{parentName:"p"},"async")," function, your code will need to follow the pattern in ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/fastify/fastify/blob/94ea67ef2d8dce8a955d510cd9081aabd036fa85/test/hooks-async.js#L269-L275"},"test/hooks-async.js"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onRequest', (request, reply, done) => {\n  const stream = fs.createReadStream('some-file', 'utf8')\n  reply.send(stream)\n})\n")),(0,r.kt)("p",null,"If you are sending a response without ",(0,r.kt)("inlineCode",{parentName:"p"},"await")," on it, make sure to always\n",(0,r.kt)("inlineCode",{parentName:"p"},"return reply"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('preHandler', async (request, reply) => {\n  setImmediate(() => { reply.send('hello') })\n\n  // This is needed to signal the handler to wait for a response\n  // to be sent outside of the promise chain\n  return reply\n})\n\nfastify.addHook('preHandler', async (request, reply) => {\n  // the fastify-static plugin will send a file asynchronously,\n  // so we should return reply\n  reply.sendFile('myfile')\n  return reply\n})\n")),(0,r.kt)("h2",{id:"application-hooks"},"Application Hooks"),(0,r.kt)("p",null,"You can hook into the application-lifecycle as well."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#onready"},"onReady")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#onclose"},"onClose")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#onroute"},"onRoute")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#onregister"},"onRegister"))),(0,r.kt)("h3",{id:"onready"},"onReady"),(0,r.kt)("p",null,"Triggered before the server starts listening for requests and when ",(0,r.kt)("inlineCode",{parentName:"p"},".ready()")," is invoked. It cannot change the routes or add new hooks.\nRegistered hook functions are executed serially.\nOnly after all ",(0,r.kt)("inlineCode",{parentName:"p"},"onReady")," hook functions have completed will the server start listening for requests.\nHook functions accept one argument: a callback, ",(0,r.kt)("inlineCode",{parentName:"p"},"done"),", to be invoked after the hook function is complete.\nHook functions are invoked with ",(0,r.kt)("inlineCode",{parentName:"p"},"this")," bound to the associated Fastify instance."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// callback style\nfastify.addHook('onReady', function (done) {\n  // Some code\n  const err = null;\n  done(err)\n})\n\n// or async/await style\nfastify.addHook('onReady', async function () {\n  // Some async code\n  await loadCacheFromDatabase()\n})\n")),(0,r.kt)("h3",{id:"onclose"},"onClose"),(0,r.kt)("a",{name:"on-close"}),(0,r.kt)("p",null,"Triggered when ",(0,r.kt)("inlineCode",{parentName:"p"},"fastify.close()")," is invoked to stop the server. It is useful when ",(0,r.kt)("a",{parentName:"p",href:"/website-next/docs/v3/Plugins"},"plugins"),' need a "shutdown" event, for example, to close an open connection to a database.'),(0,r.kt)("p",null,"The first argument is the Fastify instance, the second one the ",(0,r.kt)("inlineCode",{parentName:"p"},"done")," callback."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onClose', (instance, done) => {\n  // Some code\n  done()\n})\n")),(0,r.kt)("h3",{id:"onroute"},"onRoute"),(0,r.kt)("a",{name:"on-route"}),(0,r.kt)("p",null,"Triggered when a new route is registered. Listeners are passed a ",(0,r.kt)("inlineCode",{parentName:"p"},"routeOptions")," object as the sole parameter. The interface is synchronous, and, as such, the listeners are not passed a callback. This hook is encapsulated."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onRoute', (routeOptions) => {\n  //Some code\n  routeOptions.method\n  routeOptions.schema\n  routeOptions.url // the complete URL of the route, it will include the prefix if any\n  routeOptions.path // `url` alias\n  routeOptions.routePath // the URL of the route without the prefix\n  routeOptions.bodyLimit\n  routeOptions.logLevel\n  routeOptions.logSerializers\n  routeOptions.prefix\n})\n")),(0,r.kt)("p",null,"If you are authoring a plugin and you need to customize application routes, like modifying the options or adding new route hooks, this is the right place."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onRoute', (routeOptions) => {\n  function onPreSerialization(request, reply, payload, done) {\n    // Your code\n    done(null, payload)\n  }\n  // preSerialization can be an array or undefined\n  routeOptions.preSerialization = [...(routeOptions.preSerialization || []), onPreSerialization]\n})\n")),(0,r.kt)("h3",{id:"onregister"},"onRegister"),(0,r.kt)("a",{name:"on-register"}),(0,r.kt)("p",null,"Triggered when a new plugin is registered and a new encapsulation context is created. The hook will be executed ",(0,r.kt)("strong",{parentName:"p"},"before")," the registered code."),(0,r.kt)("p",null,"This hook can be useful if you are developing a plugin that needs to know when a plugin context is formed, and you want to operate in that specific context, thus this hook is encapsulated."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note:")," This hook will not be called if a plugin is wrapped inside ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/fastify/fastify-plugin"},(0,r.kt)("inlineCode",{parentName:"a"},"fastify-plugin")),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.decorate('data', [])\n\nfastify.register(async (instance, opts) => {\n  instance.data.push('hello')\n  console.log(instance.data) // ['hello']\n\n  instance.register(async (instance, opts) => {\n    instance.data.push('world')\n    console.log(instance.data) // ['hello', 'world']\n  }, { prefix: '/hola' })\n}, { prefix: '/ciao' })\n\nfastify.register(async (instance, opts) => {\n  console.log(instance.data) // []\n}, { prefix: '/hello' })\n\nfastify.addHook('onRegister', (instance, opts) => {\n  // Create a new array from the old one\n  // but without keeping the reference\n  // allowing the user to have encapsulated\n  // instances of the `data` property\n  instance.data = instance.data.slice()\n\n  // the options of the new registered instance\n  console.log(opts.prefix)\n})\n")),(0,r.kt)("h2",{id:"scope"},"Scope"),(0,r.kt)("a",{name:"scope"}),(0,r.kt)("p",null,"Except for ",(0,r.kt)("a",{parentName:"p",href:"#onclose"},"onClose"),", all hooks are encapsulated. This means that you can decide where your hooks should run by using ",(0,r.kt)("inlineCode",{parentName:"p"},"register")," as explained in the ",(0,r.kt)("a",{parentName:"p",href:"/website-next/docs/v3/Plugins-Guide"},"plugins guide"),". If you pass a function, that function is bound to the right Fastify context and from there you have full access to the Fastify API."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onRequest', function (request, reply, done) {\n  const self = this // Fastify context\n  done()\n})\n")),(0,r.kt)("p",null,"Note that the Fastify context in each hook is the same as the plugin where the route was registered, for example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onRequest', async function (req, reply) {\n  if (req.raw.url === '/nested') {\n    assert.strictEqual(this.foo, 'bar')\n  } else {\n    assert.strictEqual(this.foo, undefined)\n  }\n})\n\nfastify.get('/', async function (req, reply) {\n  assert.strictEqual(this.foo, undefined)\n  return { hello: 'world' }\n})\n\nfastify.register(async function plugin (fastify, opts) {\n  fastify.decorate('foo', 'bar')\n\n  fastify.get('/nested', async function (req, reply) {\n    assert.strictEqual(this.foo, 'bar')\n    return { hello: 'world' }\n  })\n})\n")),(0,r.kt)("p",null,"Warn: if you declare the function with an ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions"},"arrow function"),", the ",(0,r.kt)("inlineCode",{parentName:"p"},"this")," will not be Fastify, but the one of the current scope."),(0,r.kt)("h2",{id:"route-level-hooks"},"Route level hooks"),(0,r.kt)("a",{name:"route-hooks"}),(0,r.kt)("p",null,"You can declare one or more custom lifecycle hooks (",(0,r.kt)("a",{parentName:"p",href:"#onrequest"},"onRequest"),", ",(0,r.kt)("a",{parentName:"p",href:"#onresponse"},"onResponse"),", ",(0,r.kt)("a",{parentName:"p",href:"#preparsing"},"preParsing"),", ",(0,r.kt)("a",{parentName:"p",href:"#prevalidation"},"preValidation"),", ",(0,r.kt)("a",{parentName:"p",href:"#prehandler"},"preHandler"),", ",(0,r.kt)("a",{parentName:"p",href:"#preserialization"},"preSerialization"),", ",(0,r.kt)("a",{parentName:"p",href:"#onsend"},"onSend"),", ",(0,r.kt)("a",{parentName:"p",href:"#ontimeout"},"onTimeout"),", and ",(0,r.kt)("a",{parentName:"p",href:"#onerror"},"onError"),") hook(s) that will be ",(0,r.kt)("strong",{parentName:"p"},"unique")," for the route.\nIf you do so, those hooks are always executed as the last hook in their category. "),(0,r.kt)("p",null,"This can be useful if you need to implement authentication, where the ",(0,r.kt)("a",{parentName:"p",href:"#preparsing"},"preParsing")," or ",(0,r.kt)("a",{parentName:"p",href:"#prevalidation"},"preValidation")," hooks are exactly what you need.\nMultiple route-level hooks can also be specified as an array."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"fastify.addHook('onRequest', (request, reply, done) => {\n  // Your code\n  done()\n})\n\nfastify.addHook('onResponse', (request, reply, done) => {\n  // your code\n  done()\n})\n\nfastify.addHook('preParsing', (request, reply, done) => {\n  // Your code\n  done()\n})\n\nfastify.addHook('preValidation', (request, reply, done) => {\n  // Your code\n  done()\n})\n\nfastify.addHook('preHandler', (request, reply, done) => {\n  // Your code\n  done()\n})\n\nfastify.addHook('preSerialization', (request, reply, payload, done) => {\n  // Your code\n  done(null, payload)\n})\n\nfastify.addHook('onSend', (request, reply, payload, done) => {\n  // Your code\n  done(null, payload)\n})\n\nfastify.addHook('onTimeout', (request, reply, done) => {\n  // Your code\n  done()\n})\n\nfastify.addHook('onError', (request, reply, error, done) => {\n  // Your code\n  done()\n})\n\nfastify.route({\n  method: 'GET',\n  url: '/',\n  schema: { ... },\n  onRequest: function (request, reply, done) {\n    // This hook will always be executed after the shared `onRequest` hooks\n    done()\n  },\n  onResponse: function (request, reply, done) {\n    // this hook will always be executed after the shared `onResponse` hooks\n    done()\n  },\n  preParsing: function (request, reply, done) {\n    // This hook will always be executed after the shared `preParsing` hooks\n    done()\n  },\n  preValidation: function (request, reply, done) {\n    // This hook will always be executed after the shared `preValidation` hooks\n    done()\n  },\n  preHandler: function (request, reply, done) {\n    // This hook will always be executed after the shared `preHandler` hooks\n    done()\n  },\n  // // Example with an array. All hooks support this syntax.\n  //\n  // preHandler: [function (request, reply, done) {\n  //   // This hook will always be executed after the shared `preHandler` hooks\n  //   done()\n  // }],\n  preSerialization: (request, reply, payload, done) => {\n    // This hook will always be executed after the shared `preSerialization` hooks\n    done(null, payload)\n  },\n  onSend: (request, reply, payload, done) => {\n    // This hook will always be executed after the shared `onSend` hooks\n    done(null, payload)\n  },\n  onTimeout: (request, reply, done) => {\n    // This hook will always be executed after the shared `onTimeout` hooks\n    done()\n  },\n  onError: (request, reply, error, done) => {\n    // This hook will always be executed after the shared `onError` hooks\n    done()\n  },\n  handler: function (request, reply) {\n    reply.send({ hello: 'world' })\n  }\n})\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note"),": both options also accept an array of functions."),(0,r.kt)("h2",{id:"diagnostics-channel-hooks"},"Diagnostics Channel Hooks"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note:")," The ",(0,r.kt)("inlineCode",{parentName:"p"},"diagnostics_channel")," is currently experimental on Node.js, so\nits API is subject to change even in semver-patch releases of Node.js. For\nversions of Node.js supported by Fastify where ",(0,r.kt)("inlineCode",{parentName:"p"},"diagnostics_channel")," is\nunavailable, the hook will use the\n",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/diagnostics_channel"},"polyfill")," if it is\navailable. Otherwise this feature will not be present.")),(0,r.kt)("p",null,"Currently, one\n",(0,r.kt)("a",{parentName:"p",href:"https://nodejs.org/api/diagnostics_channel.html"},(0,r.kt)("inlineCode",{parentName:"a"},"diagnostics_channel"))," publish\nevent, ",(0,r.kt)("inlineCode",{parentName:"p"},"'fastify.initialization'"),", happens at initialization time. The Fastify\ninstance is passed into the hook as a property of the object passed in. At this\npoint, the instance can be interacted with to add hooks, plugins, routes or any\nother sort of modification."),(0,r.kt)("p",null,'For example, a tracing package might do something like the following (which is,\nof course, a simplification). This would be in a file loaded in the\ninitialization of the tracking package, in the typical "require instrumentation\ntools first" fashion.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const tracer = /* retrieved from elsehwere in the package */\nconst dc = require('diagnostics_channel')\nconst channel = dc.channel('fastify.initialization')\nconst spans = new WeakMap()\n\nchannel.subscribe(function ({ fastify }) {\n  fastify.addHook('onRequest', (request, reply, done) => {\n    const span = tracer.startSpan('fastify.request')\n    spans.set(request, span)\n    done()\n  })\n\n  fastify.addHook('onResponse', (request, reply, done) => {\n    const span = spans.get(request)\n    span.finish()\n    done()\n  })\n})\n")))}c.isMDXComponent=!0}}]);